
// checkered square
	// int y = start_y;
	// while (y < start_y + square_size)
	// {
	// 	int x = start_x;
	// 	while (x < start_x + square_size)
	// 	{
	// 		int color;
	// 		if (x % 2 == 0 && y % 2 == 0)
	// 			color = 0x00FF0000; // red
	// 		else if (x % 2 == 1 && y % 2 == 0)
	// 			color = 0x0000FF00; // Green
	// 		else if (x % 2 == 0 && y % 2 == 1)
	// 			color = 0x000000FF; //blue
	// 		else
	// 			color = 0x00FFFFFF; //white
	// 		my_mlx_pixel_put(&img, x, y, color);
	// 		x++;
	// 	}
	// 	y++;
	// }


// grid of white 10x10
	// // int cell_size = 50; // Size of each cell in the grid (50x50 pixels)
	// // int grid_rows = 10; // Number of rows in the grid
	// // int grid_cols = 10; // Number of columns in the grid
	// // int start_x = 100;  // Starting X position of the grid
	// // int start_y = 100;  // Starting Y position of the grid
	// // int color = 0x00FFFFFF; // White color for the grid lines

	// // Draw vertical lines
	// int x = start_x;
	// while (x <= start_x + (grid_cols * cell_size))
	// {
	// 	int y = start_y;
	// 	while (y <= start_y + (grid_rows * cell_size))
	// 	{
	// 		my_mlx_pixel_put(&img, x, y, color);
	// 		y++;
	// 	}
	// 	x += cell_size;
	// }

	// // // Draw horizontal lines
	// int y = start_y;
	// while (y <= start_y + (grid_rows * cell_size))
	// {
	// 	int x = start_x;
	// 	while (x <= start_x + (grid_cols * cell_size))
	// 	{
	// 		my_mlx_pixel_put(&img, x, y, color);
	// 		x++;
	// 	}
	// 	y += cell_size;
	// }


// 1 grid of white
	// int square_size = 50; // Size of the square (50x50 pixels)
	// int start_x = 5;      // Starting X position of the square
	// int start_y = 5;      // Starting Y position of the square
	// int color = 0x00FF0000; // Red color in ARGB format

	// // Draw the outline of the square using while loops
	// int y = start_y;
	// while (y < start_y + square_size)
	// {
	// 	int x = start_x;
	// 	while (x < start_x + square_size)
	// 	{
	// 		// Draw only the sides (borders) of the square
	// 		if (y == start_y || y == start_y + square_size - 1		 // Top and bottom sides
	// 			|| x == start_x || x == start_x + square_size - 1)   // Left and right sides
	// 		{
	// 			my_mlx_pixel_put(&img, x, y, color);
	// 		}
	// 		x++;
	// 	}
	// 	y++;
	// }


// rainbow full 
	// Define rainbow colors (in ARGB format)
	// int rainbow_colors[] = {
	// 	0x00FF0000, // Red
	// 	0x00FFA500, // Orange
	// 	0x00FFFF00, // Yellow
	// 	0x0000FF00, // Green
	// 	0x000000FF, // Blue
	// 	0x004B0082, // Indigo
	// 	0x00800080  // Violet
	// };
	// int num_colors = sizeof(rainbow_colors) / sizeof(rainbow_colors[0]);

	// // Draw the rainbow gradient
	// int x = 0;
	// while (x < 1920)
	// {
	// 	// Calculate the position in the gradient (0.0 to 1.0)
	// 	float t = (float)x / 1920.0f;

	// 	// Determine which two colors to interpolate between
	// 	int color_index = (int)(t * (num_colors - 1));
	// 	float local_t = t * (num_colors - 1) - color_index;

	// 	int color1 = rainbow_colors[color_index];
	// 	int color2 = rainbow_colors[color_index + 1];

	// 	// Interpolate between the two colors
	// 	int color = interpolate_color(color1, color2, local_t);

	// 	// Draw a vertical line with the interpolated color
	// 	int y = 0;
	// 	while (y < 1080)
	// 	{
	// 		my_mlx_pixel_put(&img, x, y, color);
	// 		y++;
	// 	}
	// 	x++;
	// }


// grid edges of rainbow gradient
	// // Define grid properties
	// int cell_size = 50; // Size of each cell in the grid (50x50 pixels)
	// int grid_rows = 10; // Number of rows in the grid
	// int grid_cols = 10; // Number of columns in the grid
	// int start_x = 100;  // Starting X position of the grid
	// int start_y = 100;  // Starting Y position of the grid

	// // Define rainbow colors (in ARGB format)
	// int rainbow_colors[] = {
	// 	0x00FF0000, // Red
	// 	0x00FFA500, // Orange
	// 	0x00FFFF00, // Yellow
	// 	0x0000FF00, // Green
	// 	0x000000FF, // Blue
	// 	0x004B0082, // Indigo
	// 	0x00800080  // Violet
	// };
	// int num_colors = sizeof(rainbow_colors) / sizeof(rainbow_colors[0]);

	// // Draw the 10x10 rainbow grid (edges only)
	// int row = 0;
	// while (row < grid_rows)
	// {
	// 	int col = 0;
	// 	while (col < grid_cols)
	// 	{
	// 		// Calculate the color for this cell's edges
	// 		float t = (float)(row * grid_cols + col) / (float)(grid_rows * grid_cols);
	// 		int color_index = (int)(t * (num_colors - 1));
	// 		float local_t = t * (num_colors - 1) - color_index;

	// 		int color1 = rainbow_colors[color_index];
	// 		int color2 = rainbow_colors[color_index + 1];
	// 		int color = interpolate_color(color1, color2, local_t);

	// 		// Calculate the cell's position
	// 		int cell_start_x = start_x + col * cell_size;
	// 		int cell_start_y = start_y + row * cell_size;

	// 		// Draw the top edge
	// 		int x = cell_start_x;
	// 		while (x < cell_start_x + cell_size)
	// 		{
	// 			my_mlx_pixel_put(&img, x, cell_start_y, color);
	// 			x++;
	// 		}

	// 		// Draw the bottom edge
	// 		x = cell_start_x;
	// 		while (x < cell_start_x + cell_size)
	// 		{
	// 			my_mlx_pixel_put(&img, x, cell_start_y + cell_size - 1, color);
	// 			x++;
	// 		}

	// 		// Draw the left edge
	// 		int y = cell_start_y;
	// 		while (y < cell_start_y + cell_size)
	// 		{
	// 			my_mlx_pixel_put(&img, cell_start_x, y, color);
	// 			y++;
	// 		}

	// 		// Draw the right edge
	// 		y = cell_start_y;
	// 		while (y < cell_start_y + cell_size)
	// 		{
	// 			my_mlx_pixel_put(&img, cell_start_x + cell_size - 1, y, color);
	// 			y++;
	// 		}

	// 		col++;
	// 	}
	// 	row++;
	// }


//the rainbow colour fuction(on top of int main): 
	// int	interpolate_color(int color1, int color2, float t)
	// {
	// 	int r1 = (color1 >> 16) & 0xFF;
	// 	int g1 = (color1 >> 8) & 0xFF;
	// 	int b1 = color1 & 0xFF;

	// 	int r2 = (color2 >> 16) & 0xFF;
	// 	int g2 = (color2 >> 8) & 0xFF;
	// 	int b2 = color2 & 0xFF;

	// 	int r = r1 + (int)((r2 - r1) * t);
	// 	int g = g1 + (int)((g2 - g1) * t);
	// 	int b = b1 + (int)((b2 - b1) * t);

	// 	return (r << 16) | (g << 8) | b;
	// }




// red circle
	// #include "mlx.h"
	// #include <stdio.h>
	// #include <math.h>

	// typedef struct	s_data {
	// 	void	*img;
	// 	char	*addr;
	// 	int		bits_per_pixel;
	// 	int		line_length;
	// 	int		endian;
	// }				t_data;

	// #define WIDTH 800
	// #define HEIGHT 600

	// // putting in pixels into the window
	// void	my_mlx_pixel_put(t_data *data, int x, int y, int color)
	// {
	// 	char	*dst;

	// 	dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
	// 	*(unsigned int*)dst = color;
	// }

	// void    draw_circle(t_data *data, int xc, int yc, int r, int color)
	// {
	//     int x = 0;
	//     int y = r;
	//     int p = 1 - r;

	//     while (x <= y)
	//     {
	//         my_mlx_pixel_put(data, xc + x, yc + y, color);
	//         my_mlx_pixel_put(data, xc - x, yc + y, color);
	//         my_mlx_pixel_put(data, xc + x, yc - y, color);
	//         my_mlx_pixel_put(data, xc - x, yc - y, color);
	//         my_mlx_pixel_put(data, xc + y, yc + x, color);
	//         my_mlx_pixel_put(data, xc - y, yc + x, color);
	//         my_mlx_pixel_put(data, xc + y, yc - x, color);
	//         my_mlx_pixel_put(data, xc - y, yc - x, color);

	//         if (p < 0)
	//             p = p + 2 * x + 3;
	//         else
	//         {
	//             p = p + 2 * (x - y) + 5;
	//             y--;
	//         }
	//         x++;
	//     }
	// }

	// int	main(void)
	// {
	// 	void	*mlx;
	// 	void	*mlx_win;
	// 	t_data	img;

	// 	mlx = mlx_init();
	// 	mlx_win = mlx_new_window(mlx, 1920, 1080, "Hello world!");
	// 	img.img = mlx_new_image(mlx, 1920, 1080);
	// 	img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);
		
	// 	draw_circle(&img, WIDTH / 2, HEIGHT / 2, 100, 0x00FF0000); // Draw a red circle

	// 	mlx_put_image_to_window(mlx, mlx_win, img.img, 0, 0);
	// 	mlx_loop(mlx);
	// }